## 날짜: 2024-11-06=6

### 스크럼
- 학습 목표 1 : 딥다이브 <캐싱과 조건부 요청 헤더>
- 학습 목표 2 : 웹 응용에 대한 깊은 이해
    - 세션에서 말하는 세션 ID가 사용자를 구별해주는 것임을 다시 한번 이해하게 됨
### 새로 배운 내용
#### 주제 1: 캐시 기본 동작
### 

1. 캐시가 없을 때
    - 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드함
    - 인터넷 네트워크는 느리고 비싸기 때문에 매우 비효율적
    - 브라우저 로딩 속도가 느림
2. 캐시 적용
    - 캐시 덕분에 캐시 가능 시간동안은 네트워크를 사용하지 않아도 됨
    - 비싼 네트워크 사용량을 줄일 수 있음
    - 브라우저 로딩 속도 매우 빠름

#### 주제 2: 검증 헤더

캐시 데이터와 서버 데이터가 같은지 검증하는 데이터

서버에서 클라이언트로 전송되는 헤더 정보 중 하나로, 해당 데이터가 변경되었는지 확인할 수 있는 정보를 담고 있음

- Last-Modified
    - 응답 HTTP 헤더에는 원본 서버가 리소스가 마지막으로 수정되었다고 생각하는 날짜와 시간이 포함되어 있음
    - 이전에 저장된 리소스와 동일한지 확인하기 위한 유효성 검사기로 사용
    - If-Modified-Since 헤더와 친구
- ETag 헤더
    - ETag 응답 헤더는 특정 버전의 리소스를 식별하는 식별자
    - 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 새로운 데이터 전체를 다시 다운로드하는 요청을 보내지 않음
    - 내용이 변경되었다면 mid-air collisions 라는 리소스간의 동시 다발적 수정 및 덮어쓰기 현상을 막는데 유용하게 사용
        - ex) 동시 수정 상황
            - 사용자가 서버에서 동일한 리소스를 동시에 수정하거나 덮어쓰는 상황
                - 서버는 각 리소스에 대해 고유한 ETag를 부여
                - 첫 번째 사용자가 문서를 수정한 후 서버에 저장 요청을 할 때, If-Match 헤더로 자신의 ETag를 전달
                - 서버는 현재 리소스의 ETag와 요청의 ETag를 비교
                    - 일치한다면 다른 수정 상황이 없으므로, 첫 번째 사용자의 변경 사항을 서버에 안전하게 저장 가능
                    - 다른 사용자가 해당 리소스를 이미 수정했음을 알리는 409 오류를 반환하고, 충돌 사실을 전달함
    - If-None-Match 헤더와 친구

#### 주제 3: 조건부 요청 헤더
- 검증 헤더로 조건에 따른 분기를 가능하게 하는 헤더

- 말 그대로 웹 브라우저가 서버에 요청을 보낼 때 특정 조건을 명시하는 역할

- 조건부 요청 헤더로 서버에 캐시된 데이터의 유효성을 확인 요청하면,
    -   서버는 유효하다면 데이터가 변경되지 않았음을 결과로 전달
    -  유효하지 않다면 새로운 데이터를 전송

### Last-Modified와 If-Modified-Since
1. Client의 요청에 따른 응답을 보낼 때, Server는 Last-Modified 헤더에 데이터의 최종 수정시간을 전송
2. Client는 이후 요청을 보낼 때 If-Modified-Since 헤더에 데이터의 최종 수정시간을 전송
3. Server는 Client가 보낸 헤더값으로 데이터의 최종 수정 시간을 비교
    1. 변경이 없으면 304 Not Modified로 응답 + body 없이 HTTP 메타 정보를 함께 전송
    2. 변경이 있어 새로운 데이터로 갱신해야할 경우, 200 ok와 body로 데이터를 전송
4. Client는 304 응답을 받을 경우 함께 전달받은 메타 정보로 캐시의 메타 정보를 갱신, 갱신한 캐시의 데이터를 재활용 
    - 메타 정보를 갱신하지 않으면, 클라이언트의 캐시가 서버와 일치하지 않는 정보로 유지될 수 있어 불필요한 요청이나 구 버전 데이터 제공 등의 문제가 발생 가능
    - 이를 방지하고 최적화된 캐시 관리를 위해 갱신

### 해당 방식의 단점

- 날짜 기반의 정해진 로직만 사용
- 따라서 데이터를 동일하게 수정해서 수정한 날짜는 달라지지만 데이터가 동일한 경우에도 캐시를 다시 받아와야함
- ETag의 등장 이유가 됨!

### ETag와 If-None-Match


**데이터의 유효성을 최종 수정시간이 아닌 캐시의 고유한 태그값(ETag)로 검증한다는 것을 제외하면** 

**`If-Modified-Since`와 거의 동일하다.**

1. Client의 요청에 따른 응답을 보낼 때, Server는 ETag 헤더에 캐시의 고유한 태그값을 전송한다.
2. Client는 이후 요청을 보낼 때 If-None-Match 헤더에 캐시의 고유한 태그값
3. Server는 Client가 보낸 헤더 값으로 ETag값을 비교
    1. 변경이 없으면 304 Not Modified로 응답하며 body없이 HTTP 메타 정보를 함께 전송
    2. 변경이 있어 새로운 데이터로 갱신해야 할 경우, 200 ok와 body로 데이터를 전송
4. Client는 304 응답을 받을 경우 함께 전달받은 메타 정보로 캐시의 메타 정보를 갱신, 갱신한 캐시의 데이터 재활용


### 도전 과제 1: Web Socket 개발 
- 현재 해결 진행 중
    - binarysockethandler 활용 방식 익히는 중

### 오늘의 회고
- 해야할 일이 너무 많은데.. 뭐부터 해야할지 모르겠어서 정신이 혼미하다
- 할 수 있는 건 최선을 다하는 것 밖에 없다는 걸 알지만 매일 조급한 마음으로 살아가는 건 어쩔 수 없나보다

### 참고 자료 및 링크

