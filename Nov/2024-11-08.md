## 날짜: 2024-11-08

### 스크럼
- 학습 목표 1 : React 기본 이해
- 학습 목표 2 : chatGPT API 호출 이해

### 새로 배운 내용
#### 주제 1: React 기본 이해 
### 
0. 개념
- 웹 프론트 라이브러리
- 렌더링의 의미
    - 서버는 웹문서를 사용자 브라우저에게 전달. 브라우저가 사용자가 보기 편하게 예쁘게 표시하는 과정
- SSR VS CSR
    - SSR : html 파일 먼저 다운로드 받고, 렌더링 중에 javascript를 다운받게 됨
        - 렌더링 빠른 장점이 있지만, 페이지 이동시 화면 깜빡임이 있음(js 다운로드 과정)
        - 웹페이지의 용량이 무거워질 경우, 화면 깜빡임이 길어져 사용자 경험이 나빠질 수 있음
    - CSR : 맨 처음 URL 요청에 웹 문서가 가지고 있는 모든 정보를 한번에 받아옴.
        - 초기 화면 로드가 느림
        - 그러나 로드가 되고나면 사이트 내에서 돌아다닐 때 로드되는 과정이 없어지므로 사용성이 좋아짐
        - SEO가 나쁨. 동적으로 화면을 바꿔주기 때문에 
    - SPA : 실시간으로 많은 유저의 인터랙션이 일어나 화면 깜박임이 없으면서 부드럽게 잘 동작하는 웹 사이트의 개발이 필요해짐
        - 리액트의 역할
        - index.html 파일 외에 다른 html 문서는 표시되지 않으며, index.html의 내용을 자바스크리브를 이용해 재렌더링 하는 방식으로 페이지를 구성
- CRA vs Vite vs Next.js
   - CRA: 안정성이 입증된 방식, 레거시한 방식. CSR
   - Vite: 비교적 근래에 나옴. CRA에 비해 굉장히 가볍고 빠르나 배포 전에는 문제를 파악할 수 없다는 치명적인 문제가 있음
   - Next.js: 컴포넌트 단위로 정적 생성 및 캐싱을 할 수 있다는 기능을 제공. React를 사용하면서도 SSR을 이용 가능


1. 컴포넌트
- 화면을 그리는 요소 
- 부모 컴포넌트 vs 자식 컴포넌트
    - 특정 컴포넌트가 다른 컴포넌트를 사용하고 있다면 사용되는 컴포넌트는 자식 컴포넌트.
    - 특정 컴포넌트는 부모 컴포넌트가 됨
- 내부 컴포넌트 vs 외부 컴포넌트
    - 컴포넌트 안에서 선언된 컴포넌트 -> 내부 컴포넌트 
    - 별개의 파일로 분리되어 선언된 컴포넌트 -> 외부 컴포넌트
- 왜 사용하지?
    - 재사용을 위해서

2. Props와 State
-  Props 개념
    - 부모 컴포넌트가 자식 컴포넌트에게 전달해주는 데이터
    - 데이터가 바뀌어도 새로 화면을 갱신하지 않음
- State 개념
    - 현재 상태를 표시하는 데이터
    - 해당 데이터를 바꿀 수 있는 함수를 제공
    - 데이터가 바뀌면 알아서 화면이 새로 그려짐

3. Render LifeCycle
- 화면에 컴포넌트가 그려지고 사라지는 과정
- 마운팅 : 생성될 때 / 모든 컴포넌트가 마운트 된후 데이터를 불러올 때 사용
- 업데이팅 : 업데이트 될 때 / 특정 데이터가 변했을 때, 특정 작업을 해야할 때
- 언마운팅 : 제거할 때 -> 클린업이 실행됨

4. Hooks
- 상태값 관리 및 컴포넌트 생명 주기 함수 등을 이용할 수 있는 기술

### 도전 과제 1: 웹소켓으로 받아온 데이터 출력해주기
- 발생 오류 : message 길이가 처음에 0으로 되어있었더니 map 함수에서 발생한 오류 
    - 해결 방식 : && 조건 검사를 통해 length가 0 이상일 때만 채팅 내역이 나올 수 있도록 세팅함
        ```jsx
            {messages.length > 0 && messages.map((item, index) => (
                <React.Fragment key={index}>
                    <MessageContainer chat={item} />
                </React.Fragment>
            ))}
        ```
### 도전 과제 2: mongoDB에 채팅 데이터 내용 저장
- 내용 저장시 채팅방 아이디 음수로 랜덤 발생하는 것을 확인
- timestamp를 통한 채팅 내용 정렬이 필요해서 해당 column 추가
    - 해결 방식
        - 절대값으로 설정하자니 혹시나 우연으로 발생되는 중복값이 있을까 해서 다른 방식을 고민
        - 비트 연산자를 통해서 128비트의 랜덤값 중 64비트만 사용하고 상위비트를 0으로 바꿔 양수화함
        - 이후 32비트만 사용하는 int 타입으로 캐스팅하여 사용
        ```java
            private Integer generateNewChatId() {
                return (int) (UUID.randomUUID().getLeastSignificantBits() & 0x7FFFFFFF);
            }
        ```

### 남은 해결 사항
- transcribe 클라이언트를 한번 생성하면 계속 사용할 수 있도록 해야겠다
- 더 시간을 단축시킬 방법을 찾아야

### 오늘의 회고
- 오랜만에 팀프로젝트 회의를 대면으로 했다. 대면이 확실히 소통이 잘되는 것 같은 느낌..
  보드를 통해서 각자 개발 상황도 공유하고, 서로 안되는 코드들이랑 맞춰야하는 것들 이야기를 주로 했다. 
- 열심히 살아가는 것 같긴한데 항상 뒤처지는 느낌이 든다.. 내가 인간적으로 좋은 사람일까? 매력적인 개발자인가? 에 대한 진지한 고민이 드는 요즘이다. 내가 날 믿지 못하는데, 회사가 날 믿게 할 수 있을 것 같지는 않다. 나만의 강점을 찾아가는 개발자가 되어야겠다.

### 참고 자료 및 링크